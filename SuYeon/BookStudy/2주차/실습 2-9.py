"""

# 소수 나열하기
- 정수 이하의 소수(prime number)을 모두 나열하는 알고리즘
- 소수 : 자신과 1 이외의 정수로 나누어 떨어지지 않는 정수
- 정수 n이 소수일 조건 : 2부터 n-1까지 어떤 정수로도 나누어 떨어지지 않음
- 만약 나누어 떨어지는 정수가 하나 이상 존재하면 그 수는 합성수(composite number)임
- 소수를 구하는 부분은 이중 for문 구조로 작성



# 알고리즘 개선하기 1 : 나눗셈 횟수 줄이기

- n이 2와 3으로 나누어 떨어지지 않는다면 2X2인 4와 2X3인 6으로도 나누어 떨어지지 않음(불필요한 나눗셈을 계속 실행)
- 따라서, 7이 소수인지는 7보다 작은 소수인 2,3,5로 나눗셈을 실행하는 것만으로도 충분

> 코드 구현 방법
- 소수를 구하는 과정에서 지금까지 구한 소수를 배열 prime의 원소로 저장하도록 개선
- n이 소수인지 판단할 때 배열 prime에 저장한 소수로 나눗셈을 하면 됨
- 2는 소수인 것이 분명하므로 2를 배열의 첫 원소인 prime[0]에 저장

"""



# [Do it! 실습 2-9] 1,000 이하의 소수를 나열하기(알고리즘 개선 1)

counter = 0           # 나눗셈 횟수
ptr = 0               # 이미 찾은 소수의 개수 : 0개
prime = [None] * 500  # 소수를 저장하는 배열

prime[ptr] = 2        # 2는 소수이므로 초깃값으로 지정
ptr += 1              # 이미 찾은 소수의 개수 : 1개

for n in range(3, 1001, 2):  # 홀수만을 대상으로 설정
    for i in range(1, ptr):  # 이미 찾은 소수로 나눔
                             # i 값 : '1 부터 ptr-1' 까지 반복
                             # i 는 0이 아니라 1부터 1씩 증가. 왜냐하면 판단 대상인 n이 홀수이므로,
                             # (계속) prime[0]에 저장된 2는 나눌 필요가 없음
                             # n:3일 때, 'for i in range(1, 1)' 실행 되지 않음
        counter += 1
        if n % prime[i] == 0:  # 나누어 떨어지면 소수가 아님
            break              # 반복 중단
    else:                      # 끝까지 나누어 떨어지지 않았다면
        prime[ptr] = n         # 소수로 배열에 등록
                               # -> 3(counter:0), 5(counter:1 by 3), 7(counter:2 by 3, 5) ...etc.
        ptr += 1

for i in range(ptr):  # ptr의 소수를 출력
    print(prime[i])
print(f'나눗셈을 실행한 횟수: {counter}')  # 나눗셈을 실행하는 횟수가 78,022 -> 14,622로 크게 줄음
                                           # counter는 이 알고리즘이 계산 비용을 얼마나 요구하는지 저장하는 변수
